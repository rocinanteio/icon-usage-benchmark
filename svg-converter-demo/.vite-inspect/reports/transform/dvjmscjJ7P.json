{
  "resolvedId": "/Users/ibrahim.dagdelen/Projects/Github/icon-converter-demo/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nvar _t = require(\"@babel/types\");\nvar _util = require(\"./util.js\");\nconst {\n  BOOLEAN_NUMBER_BINARY_OPERATORS,\n  createTypeAnnotationBasedOnTypeof,\n  numberTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n  if (node.name === \"undefined\") {\n    return voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => !testConstantViolations.includes(path));\n    types.push(testType.typeAnnotation);\n  }\n  if (constantViolations.length) {\n    constantViolations.push(...functionConstantViolations);\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n  if (!types.length) {\n    return;\n  }\n  return (0, _util.createUnionType)(types);\n}\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n    const status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {\n      return numberTypeAnnotation();\n    }\n    return;\n  }\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n      return parentPath;\n    }\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n    path = parentPath;\n  }\n}\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n  if (types.length) {\n    return {\n      typeAnnotation: (0, _util.createUnionType)(types),\n      ifStatement\n    };\n  }\n  return getConditionalAnnotation(binding, ifStatement, name);\n}\n\n//# sourceMappingURL=inferer-reference.js.map\n",
      "start": 1727785257075,
      "end": 1727785257117,
      "sourcemaps": null
    },
    {
      "name": "vite:react-babel",
      "start": 1727785257117,
      "end": 1727785257117,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1727785257117,
      "end": 1727785257117,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1727785257117,
      "end": 1727785257117,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1727785257117,
      "end": 1727785257117,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1727785257117,
      "end": 1727785257117,
      "order": "normal"
    },
    {
      "name": "vite-plugin-commonjs",
      "start": 1727785257117,
      "end": 1727785257117,
      "order": "normal"
    },
    {
      "name": "optimus-bundle",
      "start": 1727785257117,
      "end": 1727785257117,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1727785257117,
      "end": 1727785257117,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1727785257117,
      "end": 1727785257117,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1727785257117,
      "end": 1727785257117,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1727785257117,
      "end": 1727785257117,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1727785257117,
      "end": 1727785257117,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "result": "import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as infererReference } from \"\\u0000/Users/ibrahim.dagdelen/Projects/Github/icon-converter-demo/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js?commonjs-exports\";\nimport { __require as require$$0 } from \"\\u0000/Users/ibrahim.dagdelen/Projects/Github/icon-converter-demo/node_modules/@babel/types/lib/index.js?commonjs-wrapped\";\nimport require$$1 from \"\\u0000/Users/ibrahim.dagdelen/Projects/Github/icon-converter-demo/node_modules/@babel/traverse/lib/path/inference/util.js?commonjs-proxy\";\n\n\"use strict\";\n\nObject.defineProperty(infererReference, \"__esModule\", {\n  value: true\n});\nvar default_1 = infererReference.default = _default;\nvar _t = require$$0();\nvar _util = require$$1;\nconst {\n  BOOLEAN_NUMBER_BINARY_OPERATORS,\n  createTypeAnnotationBasedOnTypeof,\n  numberTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n  if (node.name === \"undefined\") {\n    return voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => !testConstantViolations.includes(path));\n    types.push(testType.typeAnnotation);\n  }\n  if (constantViolations.length) {\n    constantViolations.push(...functionConstantViolations);\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n  if (!types.length) {\n    return;\n  }\n  return (0, _util.createUnionType)(types);\n}\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n    const status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {\n      return numberTypeAnnotation();\n    }\n    return;\n  }\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n      return parentPath;\n    }\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n    path = parentPath;\n  }\n}\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n  if (types.length) {\n    return {\n      typeAnnotation: (0, _util.createUnionType)(types),\n      ifStatement\n    };\n  }\n  return getConditionalAnnotation(binding, ifStatement, name);\n}\n\n//# sourceMappingURL=inferer-reference.js.map\n\nexport { infererReference as __moduleExports, default_1 as default };",
      "start": 1727785257117,
      "end": 1727785257128,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          ""
        ],
        "names": [],
        "mappings": "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"
      }
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1727785257128,
      "end": 1727785257128,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1727785257128,
      "end": 1727785257128,
      "order": "normal"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1727785257128,
      "end": 1727785257128,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1727785257128,
      "end": 1727785257128,
      "order": "normal"
    }
  ]
}
