{
  "resolvedId": "/Users/ibrahim.dagdelen/Projects/Github/icon-converter-demo/node_modules/@babel/generator/lib/node/parentheses.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AssignmentExpression = AssignmentExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.ClassExpression = ClassExpression;\nexports.ArrowFunctionExpression = exports.ConditionalExpression = ConditionalExpression;\nexports.DoExpression = DoExpression;\nexports.FunctionExpression = FunctionExpression;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.Identifier = Identifier;\nexports.LogicalExpression = LogicalExpression;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.ObjectExpression = ObjectExpression;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.TSSatisfiesExpression = exports.TSAsExpression = TSAsExpression;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.UnaryLike = exports.TSTypeAssertion = UnaryLike;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nvar _t = require(\"@babel/types\");\nvar _index = require(\"./index.js\");\nconst {\n  isArrayTypeAnnotation,\n  isBinaryExpression,\n  isCallExpression,\n  isForOfStatement,\n  isIndexedAccessType,\n  isMemberExpression,\n  isObjectPattern,\n  isOptionalMemberExpression,\n  isYieldExpression,\n  isStatement\n} = _t;\nconst PRECEDENCE = new Map([[\"||\", 0], [\"??\", 0], [\"|>\", 0], [\"&&\", 1], [\"|\", 2], [\"^\", 3], [\"&\", 4], [\"==\", 5], [\"===\", 5], [\"!=\", 5], [\"!==\", 5], [\"<\", 6], [\">\", 6], [\"<=\", 6], [\">=\", 6], [\"in\", 6], [\"instanceof\", 6], [\">>\", 7], [\"<<\", 7], [\">>>\", 7], [\"+\", 8], [\"-\", 8], [\"*\", 9], [\"/\", 9], [\"%\", 9], [\"**\", 10]]);\nfunction getBinaryPrecedence(node, nodeType) {\n  if (nodeType === \"BinaryExpression\" || nodeType === \"LogicalExpression\") {\n    return PRECEDENCE.get(node.operator);\n  }\n  if (nodeType === \"TSAsExpression\" || nodeType === \"TSSatisfiesExpression\") {\n    return PRECEDENCE.get(\"in\");\n  }\n}\nfunction isTSTypeExpression(nodeType) {\n  return nodeType === \"TSAsExpression\" || nodeType === \"TSSatisfiesExpression\" || nodeType === \"TSTypeAssertion\";\n}\nconst isClassExtendsClause = (node, parent) => {\n  const parentType = parent.type;\n  return (parentType === \"ClassDeclaration\" || parentType === \"ClassExpression\") && parent.superClass === node;\n};\nconst hasPostfixPart = (node, parent) => {\n  const parentType = parent.type;\n  return (parentType === \"MemberExpression\" || parentType === \"OptionalMemberExpression\") && parent.object === node || (parentType === \"CallExpression\" || parentType === \"OptionalCallExpression\" || parentType === \"NewExpression\") && parent.callee === node || parentType === \"TaggedTemplateExpression\" && parent.tag === node || parentType === \"TSNonNullExpression\";\n};\nfunction NullableTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent);\n}\nfunction FunctionTypeAnnotation(node, parent, tokenContext) {\n  const parentType = parent.type;\n  return parentType === \"UnionTypeAnnotation\" || parentType === \"IntersectionTypeAnnotation\" || parentType === \"ArrayTypeAnnotation\" || Boolean(tokenContext & _index.TokenContext.arrowFlowReturnType);\n}\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\nfunction needsParenBeforeExpressionBrace(tokenContext) {\n  return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.arrowBody));\n}\nfunction ObjectExpression(node, parent, tokenContext) {\n  return needsParenBeforeExpressionBrace(tokenContext);\n}\nfunction DoExpression(node, parent, tokenContext) {\n  return !node.async && Boolean(tokenContext & _index.TokenContext.expressionStatement);\n}\nfunction Binary(node, parent) {\n  const parentType = parent.type;\n  if (node.type === \"BinaryExpression\" && node.operator === \"**\" && parentType === \"BinaryExpression\" && parent.operator === \"**\") {\n    return parent.left === node;\n  }\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n  if (hasPostfixPart(node, parent) || parentType === \"UnaryExpression\" || parentType === \"SpreadElement\" || parentType === \"AwaitExpression\") {\n    return true;\n  }\n  const parentPos = getBinaryPrecedence(parent, parentType);\n  if (parentPos != null) {\n    const nodePos = getBinaryPrecedence(node, node.type);\n    if (parentPos === nodePos && parentType === \"BinaryExpression\" && parent.right === node || parentPos > nodePos) {\n      return true;\n    }\n  }\n  return undefined;\n}\nfunction UnionTypeAnnotation(node, parent) {\n  const parentType = parent.type;\n  return parentType === \"ArrayTypeAnnotation\" || parentType === \"NullableTypeAnnotation\" || parentType === \"IntersectionTypeAnnotation\" || parentType === \"UnionTypeAnnotation\";\n}\nfunction OptionalIndexedAccessType(node, parent) {\n  return isIndexedAccessType(parent) && parent.objectType === node;\n}\nfunction TSAsExpression(node, parent) {\n  if ((parent.type === \"AssignmentExpression\" || parent.type === \"AssignmentPattern\") && parent.left === node) {\n    return true;\n  }\n  if (parent.type === \"BinaryExpression\" && (parent.operator === \"|\" || parent.operator === \"&\") && node === parent.left) {\n    return true;\n  }\n  return Binary(node, parent);\n}\nfunction TSUnionType(node, parent) {\n  const parentType = parent.type;\n  return parentType === \"TSArrayType\" || parentType === \"TSOptionalType\" || parentType === \"TSIntersectionType\" || parentType === \"TSRestType\";\n}\nfunction TSInferType(node, parent) {\n  const parentType = parent.type;\n  return parentType === \"TSArrayType\" || parentType === \"TSOptionalType\";\n}\nfunction TSInstantiationExpression(node, parent) {\n  const parentType = parent.type;\n  return (parentType === \"CallExpression\" || parentType === \"OptionalCallExpression\" || parentType === \"NewExpression\" || parentType === \"TSInstantiationExpression\") && !!parent.typeParameters;\n}\nfunction BinaryExpression(node, parent, tokenContext, inForStatementInit) {\n  return node.operator === \"in\" && inForStatementInit;\n}\nfunction SequenceExpression(node, parent) {\n  const parentType = parent.type;\n  if (parentType === \"SequenceExpression\" || parentType === \"ParenthesizedExpression\" || parentType === \"MemberExpression\" && parent.property === node || parentType === \"OptionalMemberExpression\" && parent.property === node || parentType === \"TemplateLiteral\") {\n    return false;\n  }\n  if (parentType === \"ClassDeclaration\") {\n    return true;\n  }\n  if (parentType === \"ForOfStatement\") {\n    return parent.right === node;\n  }\n  if (parentType === \"ExportDefaultDeclaration\") {\n    return true;\n  }\n  return !isStatement(parent);\n}\nfunction YieldExpression(node, parent) {\n  const parentType = parent.type;\n  return parentType === \"BinaryExpression\" || parentType === \"LogicalExpression\" || parentType === \"UnaryExpression\" || parentType === \"SpreadElement\" || hasPostfixPart(node, parent) || parentType === \"AwaitExpression\" && isYieldExpression(node) || parentType === \"ConditionalExpression\" && node === parent.test || isClassExtendsClause(node, parent) || isTSTypeExpression(parentType);\n}\nfunction ClassExpression(node, parent, tokenContext) {\n  return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));\n}\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || isBinaryExpression(parent) && parent.operator === \"**\" && parent.left === node || isClassExtendsClause(node, parent);\n}\nfunction FunctionExpression(node, parent, tokenContext) {\n  return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));\n}\nfunction ConditionalExpression(node, parent) {\n  const parentType = parent.type;\n  if (parentType === \"UnaryExpression\" || parentType === \"SpreadElement\" || parentType === \"BinaryExpression\" || parentType === \"LogicalExpression\" || parentType === \"ConditionalExpression\" && parent.test === node || parentType === \"AwaitExpression\" || isTSTypeExpression(parentType)) {\n    return true;\n  }\n  return UnaryLike(node, parent);\n}\nfunction OptionalMemberExpression(node, parent) {\n  return isCallExpression(parent) && parent.callee === node || isMemberExpression(parent) && parent.object === node;\n}\nfunction AssignmentExpression(node, parent, tokenContext) {\n  if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\nfunction LogicalExpression(node, parent) {\n  const parentType = parent.type;\n  if (isTSTypeExpression(parentType)) return true;\n  if (parentType !== \"LogicalExpression\") return false;\n  switch (node.operator) {\n    case \"||\":\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n    case \"&&\":\n      return parent.operator === \"??\";\n    case \"??\":\n      return parent.operator !== \"??\";\n  }\n}\nfunction Identifier(node, parent, tokenContext) {\n  var _node$extra;\n  const parentType = parent.type;\n  if ((_node$extra = node.extra) != null && _node$extra.parenthesized && parentType === \"AssignmentExpression\" && parent.left === node) {\n    const rightType = parent.right.type;\n    if ((rightType === \"FunctionExpression\" || rightType === \"ClassExpression\") && parent.right.id == null) {\n      return true;\n    }\n  }\n  if (node.name === \"let\") {\n    const isFollowedByBracket = isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    if (isFollowedByBracket && tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.forHead | _index.TokenContext.forInHead)) {\n      return true;\n    }\n    return Boolean(tokenContext & _index.TokenContext.forOfHead);\n  }\n  return node.name === \"async\" && isForOfStatement(parent, {\n    left: node,\n    await: false\n  });\n}\n\n//# sourceMappingURL=parentheses.js.map\n",
      "start": 1727785257138,
      "end": 1727785257188,
      "sourcemaps": null
    },
    {
      "name": "vite:react-babel",
      "start": 1727785257188,
      "end": 1727785257188,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1727785257188,
      "end": 1727785257188,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1727785257188,
      "end": 1727785257188,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1727785257188,
      "end": 1727785257188,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1727785257188,
      "end": 1727785257188,
      "order": "normal"
    },
    {
      "name": "vite-plugin-commonjs",
      "start": 1727785257188,
      "end": 1727785257188,
      "order": "normal"
    },
    {
      "name": "optimus-bundle",
      "start": 1727785257188,
      "end": 1727785257188,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1727785257188,
      "end": 1727785257188,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1727785257188,
      "end": 1727785257188,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1727785257188,
      "end": 1727785257188,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1727785257188,
      "end": 1727785257188,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1727785257188,
      "end": 1727785257188,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "result": "import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as parentheses } from \"\\u0000/Users/ibrahim.dagdelen/Projects/Github/icon-converter-demo/node_modules/@babel/generator/lib/node/parentheses.js?commonjs-exports\";\nimport { __require as require$$0 } from \"\\u0000/Users/ibrahim.dagdelen/Projects/Github/icon-converter-demo/node_modules/@babel/types/lib/index.js?commonjs-wrapped\";\nimport { __require as require$$1 } from \"\\u0000/Users/ibrahim.dagdelen/Projects/Github/icon-converter-demo/node_modules/@babel/generator/lib/node/index.js?commonjs-wrapped\";\n\nvar hasRequiredParentheses;\n\nfunction requireParentheses () {\n\tif (hasRequiredParentheses) return parentheses;\n\thasRequiredParentheses = 1;\n\t\"use strict\";\n\n\tObject.defineProperty(parentheses, \"__esModule\", {\n\t  value: true\n\t});\n\tparentheses.AssignmentExpression = AssignmentExpression;\n\tparentheses.Binary = Binary;\n\tparentheses.BinaryExpression = BinaryExpression;\n\tparentheses.ClassExpression = ClassExpression;\n\tparentheses.ArrowFunctionExpression = parentheses.ConditionalExpression = ConditionalExpression;\n\tparentheses.DoExpression = DoExpression;\n\tparentheses.FunctionExpression = FunctionExpression;\n\tparentheses.FunctionTypeAnnotation = FunctionTypeAnnotation;\n\tparentheses.Identifier = Identifier;\n\tparentheses.LogicalExpression = LogicalExpression;\n\tparentheses.NullableTypeAnnotation = NullableTypeAnnotation;\n\tparentheses.ObjectExpression = ObjectExpression;\n\tparentheses.OptionalIndexedAccessType = OptionalIndexedAccessType;\n\tparentheses.OptionalCallExpression = parentheses.OptionalMemberExpression = OptionalMemberExpression;\n\tparentheses.SequenceExpression = SequenceExpression;\n\tparentheses.TSSatisfiesExpression = parentheses.TSAsExpression = TSAsExpression;\n\tparentheses.TSInferType = TSInferType;\n\tparentheses.TSInstantiationExpression = TSInstantiationExpression;\n\tparentheses.UnaryLike = parentheses.TSTypeAssertion = UnaryLike;\n\tparentheses.TSIntersectionType = parentheses.TSUnionType = TSUnionType;\n\tparentheses.IntersectionTypeAnnotation = parentheses.UnionTypeAnnotation = UnionTypeAnnotation;\n\tparentheses.UpdateExpression = UpdateExpression;\n\tparentheses.AwaitExpression = parentheses.YieldExpression = YieldExpression;\n\tvar _t = require$$0();\n\tvar _index = require$$1();\n\tconst {\n\t  isArrayTypeAnnotation,\n\t  isBinaryExpression,\n\t  isCallExpression,\n\t  isForOfStatement,\n\t  isIndexedAccessType,\n\t  isMemberExpression,\n\t  isObjectPattern,\n\t  isOptionalMemberExpression,\n\t  isYieldExpression,\n\t  isStatement\n\t} = _t;\n\tconst PRECEDENCE = new Map([[\"||\", 0], [\"??\", 0], [\"|>\", 0], [\"&&\", 1], [\"|\", 2], [\"^\", 3], [\"&\", 4], [\"==\", 5], [\"===\", 5], [\"!=\", 5], [\"!==\", 5], [\"<\", 6], [\">\", 6], [\"<=\", 6], [\">=\", 6], [\"in\", 6], [\"instanceof\", 6], [\">>\", 7], [\"<<\", 7], [\">>>\", 7], [\"+\", 8], [\"-\", 8], [\"*\", 9], [\"/\", 9], [\"%\", 9], [\"**\", 10]]);\n\tfunction getBinaryPrecedence(node, nodeType) {\n\t  if (nodeType === \"BinaryExpression\" || nodeType === \"LogicalExpression\") {\n\t    return PRECEDENCE.get(node.operator);\n\t  }\n\t  if (nodeType === \"TSAsExpression\" || nodeType === \"TSSatisfiesExpression\") {\n\t    return PRECEDENCE.get(\"in\");\n\t  }\n\t}\n\tfunction isTSTypeExpression(nodeType) {\n\t  return nodeType === \"TSAsExpression\" || nodeType === \"TSSatisfiesExpression\" || nodeType === \"TSTypeAssertion\";\n\t}\n\tconst isClassExtendsClause = (node, parent) => {\n\t  const parentType = parent.type;\n\t  return (parentType === \"ClassDeclaration\" || parentType === \"ClassExpression\") && parent.superClass === node;\n\t};\n\tconst hasPostfixPart = (node, parent) => {\n\t  const parentType = parent.type;\n\t  return (parentType === \"MemberExpression\" || parentType === \"OptionalMemberExpression\") && parent.object === node || (parentType === \"CallExpression\" || parentType === \"OptionalCallExpression\" || parentType === \"NewExpression\") && parent.callee === node || parentType === \"TaggedTemplateExpression\" && parent.tag === node || parentType === \"TSNonNullExpression\";\n\t};\n\tfunction NullableTypeAnnotation(node, parent) {\n\t  return isArrayTypeAnnotation(parent);\n\t}\n\tfunction FunctionTypeAnnotation(node, parent, tokenContext) {\n\t  const parentType = parent.type;\n\t  return parentType === \"UnionTypeAnnotation\" || parentType === \"IntersectionTypeAnnotation\" || parentType === \"ArrayTypeAnnotation\" || Boolean(tokenContext & _index.TokenContext.arrowFlowReturnType);\n\t}\n\tfunction UpdateExpression(node, parent) {\n\t  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n\t}\n\tfunction needsParenBeforeExpressionBrace(tokenContext) {\n\t  return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.arrowBody));\n\t}\n\tfunction ObjectExpression(node, parent, tokenContext) {\n\t  return needsParenBeforeExpressionBrace(tokenContext);\n\t}\n\tfunction DoExpression(node, parent, tokenContext) {\n\t  return !node.async && Boolean(tokenContext & _index.TokenContext.expressionStatement);\n\t}\n\tfunction Binary(node, parent) {\n\t  const parentType = parent.type;\n\t  if (node.type === \"BinaryExpression\" && node.operator === \"**\" && parentType === \"BinaryExpression\" && parent.operator === \"**\") {\n\t    return parent.left === node;\n\t  }\n\t  if (isClassExtendsClause(node, parent)) {\n\t    return true;\n\t  }\n\t  if (hasPostfixPart(node, parent) || parentType === \"UnaryExpression\" || parentType === \"SpreadElement\" || parentType === \"AwaitExpression\") {\n\t    return true;\n\t  }\n\t  const parentPos = getBinaryPrecedence(parent, parentType);\n\t  if (parentPos != null) {\n\t    const nodePos = getBinaryPrecedence(node, node.type);\n\t    if (parentPos === nodePos && parentType === \"BinaryExpression\" && parent.right === node || parentPos > nodePos) {\n\t      return true;\n\t    }\n\t  }\n\t  return undefined;\n\t}\n\tfunction UnionTypeAnnotation(node, parent) {\n\t  const parentType = parent.type;\n\t  return parentType === \"ArrayTypeAnnotation\" || parentType === \"NullableTypeAnnotation\" || parentType === \"IntersectionTypeAnnotation\" || parentType === \"UnionTypeAnnotation\";\n\t}\n\tfunction OptionalIndexedAccessType(node, parent) {\n\t  return isIndexedAccessType(parent) && parent.objectType === node;\n\t}\n\tfunction TSAsExpression(node, parent) {\n\t  if ((parent.type === \"AssignmentExpression\" || parent.type === \"AssignmentPattern\") && parent.left === node) {\n\t    return true;\n\t  }\n\t  if (parent.type === \"BinaryExpression\" && (parent.operator === \"|\" || parent.operator === \"&\") && node === parent.left) {\n\t    return true;\n\t  }\n\t  return Binary(node, parent);\n\t}\n\tfunction TSUnionType(node, parent) {\n\t  const parentType = parent.type;\n\t  return parentType === \"TSArrayType\" || parentType === \"TSOptionalType\" || parentType === \"TSIntersectionType\" || parentType === \"TSRestType\";\n\t}\n\tfunction TSInferType(node, parent) {\n\t  const parentType = parent.type;\n\t  return parentType === \"TSArrayType\" || parentType === \"TSOptionalType\";\n\t}\n\tfunction TSInstantiationExpression(node, parent) {\n\t  const parentType = parent.type;\n\t  return (parentType === \"CallExpression\" || parentType === \"OptionalCallExpression\" || parentType === \"NewExpression\" || parentType === \"TSInstantiationExpression\") && !!parent.typeParameters;\n\t}\n\tfunction BinaryExpression(node, parent, tokenContext, inForStatementInit) {\n\t  return node.operator === \"in\" && inForStatementInit;\n\t}\n\tfunction SequenceExpression(node, parent) {\n\t  const parentType = parent.type;\n\t  if (parentType === \"SequenceExpression\" || parentType === \"ParenthesizedExpression\" || parentType === \"MemberExpression\" && parent.property === node || parentType === \"OptionalMemberExpression\" && parent.property === node || parentType === \"TemplateLiteral\") {\n\t    return false;\n\t  }\n\t  if (parentType === \"ClassDeclaration\") {\n\t    return true;\n\t  }\n\t  if (parentType === \"ForOfStatement\") {\n\t    return parent.right === node;\n\t  }\n\t  if (parentType === \"ExportDefaultDeclaration\") {\n\t    return true;\n\t  }\n\t  return !isStatement(parent);\n\t}\n\tfunction YieldExpression(node, parent) {\n\t  const parentType = parent.type;\n\t  return parentType === \"BinaryExpression\" || parentType === \"LogicalExpression\" || parentType === \"UnaryExpression\" || parentType === \"SpreadElement\" || hasPostfixPart(node, parent) || parentType === \"AwaitExpression\" && isYieldExpression(node) || parentType === \"ConditionalExpression\" && node === parent.test || isClassExtendsClause(node, parent) || isTSTypeExpression(parentType);\n\t}\n\tfunction ClassExpression(node, parent, tokenContext) {\n\t  return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));\n\t}\n\tfunction UnaryLike(node, parent) {\n\t  return hasPostfixPart(node, parent) || isBinaryExpression(parent) && parent.operator === \"**\" && parent.left === node || isClassExtendsClause(node, parent);\n\t}\n\tfunction FunctionExpression(node, parent, tokenContext) {\n\t  return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));\n\t}\n\tfunction ConditionalExpression(node, parent) {\n\t  const parentType = parent.type;\n\t  if (parentType === \"UnaryExpression\" || parentType === \"SpreadElement\" || parentType === \"BinaryExpression\" || parentType === \"LogicalExpression\" || parentType === \"ConditionalExpression\" && parent.test === node || parentType === \"AwaitExpression\" || isTSTypeExpression(parentType)) {\n\t    return true;\n\t  }\n\t  return UnaryLike(node, parent);\n\t}\n\tfunction OptionalMemberExpression(node, parent) {\n\t  return isCallExpression(parent) && parent.callee === node || isMemberExpression(parent) && parent.object === node;\n\t}\n\tfunction AssignmentExpression(node, parent, tokenContext) {\n\t  if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern(node.left)) {\n\t    return true;\n\t  } else {\n\t    return ConditionalExpression(node, parent);\n\t  }\n\t}\n\tfunction LogicalExpression(node, parent) {\n\t  const parentType = parent.type;\n\t  if (isTSTypeExpression(parentType)) return true;\n\t  if (parentType !== \"LogicalExpression\") return false;\n\t  switch (node.operator) {\n\t    case \"||\":\n\t      return parent.operator === \"??\" || parent.operator === \"&&\";\n\t    case \"&&\":\n\t      return parent.operator === \"??\";\n\t    case \"??\":\n\t      return parent.operator !== \"??\";\n\t  }\n\t}\n\tfunction Identifier(node, parent, tokenContext) {\n\t  var _node$extra;\n\t  const parentType = parent.type;\n\t  if ((_node$extra = node.extra) != null && _node$extra.parenthesized && parentType === \"AssignmentExpression\" && parent.left === node) {\n\t    const rightType = parent.right.type;\n\t    if ((rightType === \"FunctionExpression\" || rightType === \"ClassExpression\") && parent.right.id == null) {\n\t      return true;\n\t    }\n\t  }\n\t  if (node.name === \"let\") {\n\t    const isFollowedByBracket = isMemberExpression(parent, {\n\t      object: node,\n\t      computed: true\n\t    }) || isOptionalMemberExpression(parent, {\n\t      object: node,\n\t      computed: true,\n\t      optional: false\n\t    });\n\t    if (isFollowedByBracket && tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.forHead | _index.TokenContext.forInHead)) {\n\t      return true;\n\t    }\n\t    return Boolean(tokenContext & _index.TokenContext.forOfHead);\n\t  }\n\t  return node.name === \"async\" && isForOfStatement(parent, {\n\t    left: node,\n\t    await: false\n\t  });\n\t}\n\n\t//# sourceMappingURL=parentheses.js.map\n\treturn parentheses;\n}\n\nexport { requireParentheses as __require };",
      "start": 1727785257188,
      "end": 1727785257190,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          ""
        ],
        "names": [],
        "mappings": "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"
      }
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1727785257190,
      "end": 1727785257190,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1727785257190,
      "end": 1727785257190,
      "order": "normal"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1727785257190,
      "end": 1727785257190,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1727785257190,
      "end": 1727785257190,
      "order": "normal"
    }
  ]
}
